<template>	<div class="window" :style="frameStyles" @mousedown="windowTapped">		<span ref="resizeHorz" class="resize-line-horizontal"></span>		<span ref="resizeVert" class="resize-line-vertical"></span>		<titlebar ref="titlebar"				  :caption="this.frameCaption"				  @drag-started="onDragStarted"				  @system-button-double-tapped="closeWindow"/>		<div ref="client" class="client">			<slot></slot>		</div>	</div></template><script lang="ts">import Component, {mixins} from "vue-class-component";import {Point, WindowMode} from "@/components/kernel/ui/Windows/WindowProperties";import Frame from "@/components/kernel/ui/Base/Frame.vue";import Titlebar from "@/components/kernel/ui/Components/Windows/Titlebar.vue";import FocussableFrame from "@/components/kernel/ui/Base/Mixins/FocussableFrame.vue";import {Prop, Watch} from "vue-property-decorator";import {GetWindowManager} from "@/components/kernel/ui/Windows/WindowManager";import GuiApplication from "@/components/kernel/ui/Base/GuiApplication.vue";import {Message, MessageBus} from "@/components/kernel/ui/MessageBus";import WindowDragHost, {DragMode} from "@/components/kernel/ui/Components/Windows/WindowDragHost.vue";@Component(	{		components: {Titlebar},		data()		{			return {				handle: 0,				style: null,				zOrder: 0,			}		}	})	export default class Window extends mixins(Frame, FocussableFrame)	{		@Prop() application: GuiApplication;		/**		 * Style of the frame		 */		public style: WindowMode = WindowMode.Normal;		/**		 * Unique window id, assigned by the WindowManager		 */		public handle = 0;		/**		 * The z-order of this window.		 * A value of 0 means that this window is currently active window.		 */		public zOrder = 0;		mounted()		{			GetWindowManager().register(this);		}		beforeDestroy()		{			GetWindowManager().unregister(this);		}		closeWindow()		{			// @todo: support more windows per app			this.application.terminateApplication();		}		/**		 * The user tapped on the window. From here we can start multiple actions:		 *		 * - Make the window active if it was not		 * - Start a resize action if the user touched the drag handles		 */		windowTapped(mouseEvent: MouseEvent)		{			if(!this.frameActive)				GetWindowManager().bringToFront(this);			// Lets check if the user touched the window border, if there is any.			if(!this.isResizable || !this.isTouchingBorder(mouseEvent))				return;			this.onDragStarted(				this.determinateDragMode(mouseEvent),				[mouseEvent.clientX, mouseEvent.clientY] // :x			);		}		/**		 * Returns true of the user is touching the underlying window element		 */		private isTouchingBorder(mouseEvent: MouseEvent): boolean		{			return mouseEvent.target === this.$el;		}		/**		 * Determine which drag mode the user wants to use		 */		private determinateDragMode(mouseEvent: MouseEvent): DragMode		{			const top = mouseEvent.offsetY < WindowDragHost.dragHandleLength;			const left = mouseEvent.offsetX < WindowDragHost.dragHandleLength;			const right = mouseEvent.offsetX >= this.frameSize.width - WindowDragHost.dragHandleLength;			const bottom = mouseEvent.offsetY >= this.frameSize.height - WindowDragHost.dragHandleLength;			if(top && left) return DragMode.TopLeft;			if(top && right) return DragMode.TopRight;			if(left && bottom) return DragMode.BottomLeft;			if(bottom && right) return DragMode.BottomRight;			if(left) return DragMode.Left;			if(top) return DragMode.Top;			if(bottom) return DragMode.Bottom;			if(right) return DragMode.Right;			// This should never happen			return DragMode.Resize;		}		/**		 * Returns true if this window is resizable		 */		get isResizable(): boolean		{			if(!this.$refs.resizeHorz)				return false;			return (this.$refs.resizeHorz as HTMLElement).style.display != 'none';		}		onDragStarted(mode: DragMode, args: Point | number[])		{			// Translate the x,y to the window offset			MessageBus.$emit(Message.DragStarted, [				this.handle, mode, {					x: Math.abs(this.frameSize.left - args[0]),					y: Math.abs(this.frameSize.top - args[1])				}			]);		}		protected updateWindowStyle()		{			switch(this.style)			{				case WindowMode.Normal:					this.setFramePosition(this.frameSize.left, this.frameSize.top);					this.setFrameSize(this.frameSize.width, this.frameSize.height);					break;				case WindowMode.Maximized:					this.setFramePosition(0, 0);					this.setFrameSize(window.innerWidth, window.innerHeight);					break;				case WindowMode.Minimized:					break;				case WindowMode.Hidden:					break;			}		}		/**		 * Passes the focus state of the window to the title bar		 */		@Watch('frameActive')		public focusChanged()		{			(this.$refs.titlebar as Titlebar).frameActive = this.frameActive;		}		@Watch('zOrder')		public zOrderChanged()		{			this.zOrder === 0? this.focus() : this.unFocus();		}		public set windowStyle(value: WindowMode)		{			if(this.style == WindowMode.Normal)				this.retainCurrentFrame();			this.style = value;			this.updateWindowStyle();		}		public get windowStyle()		{			return this.style;		}		get frameStyles()		{			const styles = this.getFrameStylesAsArray();			styles.push('z-index: ' + (1000 - this.zOrder));			if(this.frameSize.isHidden)				styles.push('display:none');			return styles.join(';');		}	}</script>