<template>	<div class="window" :style="frameStyles" @click="windowTapped">		<span class="resize-line-horizontal"></span>		<span class="resize-line-vertical"></span>		<titlebar ref="titlebar" :caption="this.frameCaption" @drag-started="onDragStarted"/>		<div class="client">			<slot></slot>		</div>	</div></template><script lang="ts">	import Component, {mixins} from "vue-class-component";	import {Point, WindowMode} from "@/components/kernel/ui/Windows/WindowProperties";	import Frame from "@/components/kernel/ui/Base/Frame.vue";	import Titlebar from "@/components/kernel/ui/Components/Windows/Titlebar.vue";	import FocussableFrame from "@/components/kernel/ui/Base/Mixins/FocussableFrame.vue";	import {Prop, Watch} from "vue-property-decorator";	import {GetWindowManager} from "@/components/kernel/ui/Windows/WindowManager";	import GuiApplication from "@/components/kernel/ui/Base/GuiApplication.vue";	import {Message, MessageBus} from "@/components/kernel/ui/MessageBus";	@Component(	{		components: {Titlebar},		data()		{			return {				handle: 0,				style: null,				zOrder: 0,			}		}	})	export default class Window extends mixins(Frame, FocussableFrame)	{		@Prop() application: GuiApplication;		/**		 * Style of the frame		 */		public style: WindowMode = WindowMode.Normal;		/**		 * Unique window id, assigned by the WindowManager		 */		public handle = 0;		public zOrder = 0;		mounted()		{			GetWindowManager().register(this);		}		windowTapped()		{			if(!this.frameActive)				GetWindowManager().bringToFront(this);		}		onDragStarted(args: Point)		{			// Translate the x,y to the window offset			MessageBus.$emit(Message.DragStarted, [				this.handle, {					x: Math.abs(this.frameSize.left - args[0]),					y: Math.abs(this.frameSize.top - args[1])				}			]);		}		beforeDestroy()		{			GetWindowManager().unregister(this);		}		protected updateWindowStyle()		{			switch(this.style)			{				case WindowMode.Normal:					this.setFramePosition(this.frameSize.left, this.frameSize.top);					this.setFrameSize(this.frameSize.width, this.frameSize.height);					break;				case WindowMode.Maximized:					this.setFramePosition(0, 0);					this.setFrameSize(window.innerWidth, window.innerHeight);					break;				case WindowMode.Minimized:					break;				case WindowMode.Hidden:					break;			}		}		/**		 * Passes the focus state of the window to the title bar		 */		@Watch('frameActive')		public focusChanged()		{			(this.$refs.titlebar as Titlebar).frameActive = this.frameActive;		}		@Watch('zOrder')		public zOrderChanged()		{			this.zOrder === 0? this.focus() : this.unFocus();		}		public set windowStyle(value: WindowMode)		{			if(this.style == WindowMode.Normal)				this.retainCurrentFrame();			this.style = value;			this.updateWindowStyle();		}		public get windowStyle()		{			return this.style;		}		get frameStyles()		{			const styles = this.getFrameStylesAsArray();			styles.push('z-index: ' + (1000 - this.zOrder));			if(this.frameSize.isHidden)				styles.push('display:none');			return styles.join(';');		}	}</script>